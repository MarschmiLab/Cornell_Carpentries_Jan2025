---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 01-r-plotting.md in _episodes_rmd/
source: Rmd
title: "R for Plotting"
teaching: 0
exercises: 0
questions: ""
objectives: ""
keypoints: ""
---



## Introduction to R and RStudio

In this session we will be testing the hypothesis that a country's life expectancy is related to the total value of its finished goods and services, also known as the Gross Domestic Product (GDP).
To test this hypothesis, we'll need two things: data and a platform to analyze the data.

You already [downloaded the data](setup_instructions). But what platform will we use to analyze the data? We have many options!

TODO: *Add link to information about reprodcible research or leave discussion for later?*

We could try to use a spreadsheet program like Microsoft Excel or Google sheets that have limited access, less flexiblity, and don't easily allow for things that are criticial to "reproducible" research, like easily sharing the steps used to explore and make changes to the original data.

Instead, we'll use the a programming language to test our hypothesis. Today we will use R, but we could have also used Python for the same reasons we chose R (and we teach workshops for both languages). Both R and Python are freely available, the instructions you use to do the analysis are easily shared, and by using reproducible practices, it's straightforward to add more data or to change settings like colors or the size of a plotting symbol.

TODO: *Check or update text to become an expandable discussion box*
> ## But why R and not Python?
>>
[There's no great reason](http://www.academichermit.com/2020/03/23/Why-R.html).
>>Although there are subtle differences between the languages, it's ultimately a matter of personal preference. Both are powerful and popular languages that have very well developed and welcoming communities of scientists that use them. As you learn more about R you may find things that are annoying in R that aren't so annoying in Python; the same could be said of learning Python. If the community you work in uses R, then you're in the right place.
>
> {: .source}
{: .discussion}

To run R, all you really need is the R program, which is available for computers running the Windows, Mac OS X, or Linux operating systems. You downloaded R while getting [set up](setup_instructions) for this workshop.

To make your life in R easier, there is a great (and free!) program called RStudio that you also downloaded and used during [set up](setup_instructions). As we work today, we'll use features that are available in RStudio for writing and running code, managing projects, installing packages, getting help, and much more. It is important to remember that R and RStudio are different, but complementary programs. You need R to use RStudio.

TODO: Change exercise to .md format blocks & add resources to use Rstudio on GreatLakes
> ## Exercise
> **Question:** Can you think of a reason you might not want to use RStudio?
>
> **Answer:** On some high performance computer systems (e.g. Amazon Web Services) you typically can't get a display like RStudio to open. If you're at the University of Michigan and have access to Great Lakes, then you might want to learn more about [resources](broken link) to run RStudio on Great Lakes.

To get started, we'll spend a little time getting familiar with the RStudio environment and setting it up to suit your tastes. When you start RStudio, you'll have three panels.

![](01-r-plotting-assets/initial_rstudio.png)

On the left you'll have a panel with three tabs - Console, Terminal, and Jobs. The Console tab is what running R from the command line looks like. This is where you can enter R code. Try typing in `2+2` at the prompt (>). In the upper right panel are tabs indicating the Environment, History, and a few other things. If you click on the History tab, you'll see the command you ran at the R prompt.

![](01-r-plotting-assets/history.png)

In the lower right panel are tabs for Files, Plots, Packages, Help, and Viewer. You used the Packages tab to install tidyverse.

We'll spend more time in each of these tabs as we go through the workshop so we won't spend a lot of time discussing them now.

You might want to alter the appearance of your RStudio window. The default appearance has a white background with black text. If you go to the Tools menu at the top of your screen, you'll see a "Global options" menu at the bottom of the drop down; select that.

![](01-r-plotting-assets/global_options.png)

From there you will see the ability to alter numerous things about RStudio. Under the Appearances tab you can select the theme you like most. As you can see there's a lot in Global options that you can set to improve your experience in RStudio. Most of these settings are a matter of personal preference.

However, you can update settings to help you to insure the reproducibility of your code. In the General tab, none of the selectors in the R Sessions, Workspace, and History should be selected. In additon, the toggle next to "Save workspace to .RData on exit" should be set to never. These setting will help ensure that things you worked on previously don't carry over between sessions.

![](01-r-plotting-assets/general_options.png)

Let's get going on our analysis!

One of the helpful features in RStudio is the ability to create a project. A project is a special directory that contains all of the code and data that you will need to run an analysis.

At the top of your screen you'll see the "File" menu. Select that menu and then the menu for "New Project...".

![](01-r-plotting-assets/new_project_menu.png)

When the smaller window opens, select "Existing Directory" and then the "Browse" button in the next window.

![](01-r-plotting-assets/existing_directory.png)
![](01-r-plotting-assets/browse.png)

Navigate to the directory that contains your code and data from the setup instructions and click the "Open" button.

![](01-r-plotting-assets/navigate_to_project.png)

Then click the "Create Project" button.

![](01-r-plotting-assets/create_project.png)

Did you notice anything change?

In the lower right corner of your RStudio session, you should notice that your Files tab is now your project directory. You'll also see a file called my_project.Rproj in that directory.

From now on, you should start RStudio by double clicking on that file. This will make sure you are in the correct directory when you run your analysis.

![](01-r-plotting-assets/files_with_rproj.png)

We'd like to create a file where we can keep track of our R code.

Back in the "File" menu, you'll see the first option is "New File". Selecting "New File" opens another menu to the right and the first option is "R Script". Select "R Script".

TODO: *Confirm paths with larger group/unix group*
Now we have a fourth panel in the upper left corner of RStudio that includes an **Editor** tab with an untitled R Script. Let's save this file as `gdp_population.R` in our project directory.

We will be entering R code into the **Editor** tab to run in our **Console** panel.

On line 1 of `gdp_population.R`, type `2+2`.

With your cursor on the line with the `2+2`, click the button that says "Run". You should be able to see that `2+2` was run in the Console.

As you write more code, you can highlight multiple lines and then click "Run" to run all of the lines you have selected.

Let's delete the line with 2+2 and replace it with `library(tidyverse)`.

Go ahead and run that line in the **Console** by clicking the <kbd>Run</kbd> button on the top right of the **Editor** tab and choosing <kbd>Run Selected Lines</kbd>


~~~
library(tidyverse)
~~~
{: .language-r}



~~~
â”€â”€ [1mAttaching packages[22m â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.0 â”€â”€
~~~
{: .output}



~~~
[32mâœ”[39m [34mggplot2[39m 3.3.2     [32mâœ”[39m [34mpurrr  [39m 0.3.4
[32mâœ”[39m [34mtibble [39m 3.0.4     [32mâœ”[39m [34mdplyr  [39m 1.0.2
[32mâœ”[39m [34mtidyr  [39m 1.1.2     [32mâœ”[39m [34mstringr[39m 1.4.0
[32mâœ”[39m [34mreadr  [39m 1.4.0     [32mâœ”[39m [34mforcats[39m 0.5.0
~~~
{: .output}



~~~
â”€â”€ [1mConflicts[22m â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
[31mâœ–[39m [34mdplyr[39m::[32mfilter()[39m masks [34mstats[39m::filter()
[31mâœ–[39m [34mdplyr[39m::[32mlag()[39m    masks [34mstats[39m::lag()
~~~
{: .output}

TODO: *Add example output from loading library and/or discuss messages get when loading a package?*

TODO: *Change to testimonal or other highlighted box?*
## Hint / Pro-tip
Those of us that use R on a daily basis use cheat sheets to help us remember how to use various R functions. If you haven't already, print out the PDF versions of the cheat sheets that were in the setup instructions.

You can also find them in RStudio by going to the "Help" menu and selecting "Cheat Sheets". The two that will be most helpful in this workshop are "Data Visualization with ggplot2" and "Data Transformation with dplyr".


---

# Loading and reviewing data

We will import a subset file from the gapminder dataset called `gapminder_1997.csv`. There are many ways to import data into R but for your first plot we will use RStudio's file menu to import and display this data. As we move through this process, RStudio will translate these *point and click* commands into code for us.

In RStudio select "File" > "Import Dataset" > "From Text (readr)".

TODO: *Update '<<data directory>> to match the directory structure from setup*
The file is located in the directory <<data directory>>, click the "browse" button and select the file named `gapminder_1997.csv`. A preview of the data will appear in the window. You can see there are a lot of Import Options listed, but R has chosen the correct defaults for this particular file.

We can see in that box that our data will be imported with the Name: "gapminder_1997". Also note that this screen will show you all the code that will be run when you import your data in the lower right "Code Preview". Since everything looks good, click the "Import" button to bring your data into R.

After you've imported your data, you will a table open in a new tab in the top left corner of RStudio. This is a quick way to browse your data to make sure everything looks like it has been imported correctly. To review the data, click on the new tab.

We see that our data has 5 columns (variables).

Each row contains life expectancy ("lifeExp"), the total population ("pop"), and the per capita gross domestic product ("gdpPercap") for a given country ("country").

There is also a column that says which continent each country is in ("continent"). Note that both North America and South America are combined into one category called "Americas".

After we've reviewed the data, you'll want to make sure to click the tab in the upper left to return to your `gdp_population.R` file so we can start writing some code.

Now look in the **Environment** tab in the upper right corner of RStudio. Here you will see a list of all the objects you've created or imported during your R session. You will now see `gapminder_1997` listed here as well.

Finally, take a look at the **Console** at the bottom left part of the RStudio screen. Here you will see the commands that were run for you to import your data in addition to associated metadata and warnings.

# Understanding commands

Let's start by looking at the code RStudio ran for us by copying and pasting the first line from the console into our `gdp_population.R` file that is open in the **Editor** window.

TODO: *Confirm that this is the example output*
```
gapminder_1997 <- read_csv(file = "SoftwareCarpentry/SoftwareCarpentry09_05/myData/gapminder_data.csv")

```

You should now have a line of text in your code file that started with `gapminder` and ends with a `)` symbol.

What if we want to run this command from our code file?

In order to run code that you've typed in the editor, you have a few options. We can click <kbd>Run</kbd> again from the right side of the **Editor** tab but the quickest way to run the code is by pressing <kbd>Ctrl</kbd>+<kbd>Enter</kbd> on your keyboard.

This will run the line of code that currently contains your cursor and will move your cursor to the next line. Note that when Rstudio runs your code, it basically just copies your code from the **Editor** window to the **Console** window, just like what happened when we selected <kbd>Run Selected Line(s)</kbd>.

Let's take a closer look at the parts of this command.

Starting from the left, the first thing we see is `gapminder_1997`. We viewed the contents of this file after it was imported so we know that `gapminder_1997` acts as a placeholder for a table of data.

TODO: *Create exercise here*
> # Running parts of our code
> If we highlight just `gapminder_1997` within our code file and press <kbd>Ctrl</kbd>+<kbd>Enter</kbd> on our keyboard, what do we see?
>> Solution: we see an output with a similar format to what we saw in the Viewer tab

TODO: *Clarify/correct wording here*
In R terms, `gapminder_1997` is a named **object** that references or stores something, in this case that's a specific table of data.

TODO: *Update to be a collapsable option & determine how exhaustive to be*
> # Guidelines on naming objects:
>> - You want your object names to be explicit and not too long.
>> - They cannot start with a number (2x is not valid, but x2 is).
>> - R is case sensitive, so for example, weight_kg is different from Weight_kg.
>> - There are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for, see [here](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html) for a complete list). If in doubt, check the help to see if the name is already in use.
>> - It's best to avoid dots (.) within names. Many function names in R itself have them and dots also have a special meaning (methods) in R and other programming languages.
>> - It is recommended to use nouns for object names and verbs for function names.
>> - Be consistent in the styling of your code, such as where you put spaces, how you name objects, etc. Using a consistent coding style makes your code clearer to read for your future self and your collaborators. One popular style guide can be found through the [tidyverse](https://style.tidyverse.org/).
> {: .source}
{: .keypoint}

Looking back at the command in our code file, the second thing we see if a `<-` symbol, which is the **assignment operator**. It assigns values generated or typed on the right to objects on the left. An alternative symbol that you might see used as an **assignment operator** is the `=` but it is clearer to only use `<-` for assignment. We use this symbol so often that RStudio has a keyboard short cut for it: <kbd>Alt</kbd>+<kbd>-</kbd> on Windows, and <kbd>Option</kbd>+<kbd>-</kbd> on Mac.

TODO: *Add optional exercise to use 'bad' object names and try to assign values to those?*
> ## Challenge - Assign values to objects
> Try to assign values to some new objects
> 
> ~~~
> 1number <- 3
> Flower <- "marigold"
> flower <- "rose"
> favorite number <- 12
> ~~~
> {: .language-r}
> 
> 
> 
> ~~~
> Error: <text>:1:2: unexpected symbol
> 1: 1number
>      ^
> ~~~
> {: .error}
> {: .source}
{: .challenge}

The next part of the command is `read_csv(file = "SoftwareCarpentry/SoftwareCarpentry09_05/myData/gapminder_data.csv")`. This has a few different key parts. The first part `

You call a function in R by typing it's name followed by opening then closing parenthesis.  Let's try to run the function without anything inside the parenthesis.

~~~
read_csv()
~~~
{: .language-r}



~~~
Error in read_delimited(file, tokenizer, col_names = col_names, col_types = col_types, : argument "file" is missing, with no default
~~~
{: .error}

We get an error message!
```
Error in read_delimited(file, tokenizer, col_names = col_names, col_types = col_types,  :
  argument "file" is missing, with no default
```
{ .error: error messages.}


Some functions like `read_csv` require additional pieces of information in order to do their job, we call these additional values "arguments" or "parameters."

You pass **arguments** to a function by placing values in between the parenthesis. Argument names precede their values but most are optional if you pass them in a certain order.

When you need to pass in multiple arguments to a function you will separate those values with commas. But that's just a quick summary -- we will see examples of those later.

TODO: *Add challenge showing a function that doesn't need arguments*
> ## Challenge: Do all functions need arguments
>> Let's test some other functions
>>
>>~~~
>>  Sys.Date()
>>~~~
>>{: .language-r}
>>
>>
>>
>>~~~
>>[1] "2020-11-19"
>>~~~
>>{: .output}
>>
>
> {: .source}
{: .callout}

Each function has a help page that documents what arguments the function expects and what value it will return. You can bring up the help page a few different ways. If you have typed the function name in the **Editor** windows, you can put your cursor on the function name and press <kbd>F1</kbd> to open help page in the **Help** viewer in the lower right corner of RStudio. You can also type `?` followed by the function name in the console. For example `?read_csv`. The help pages often have useful examples of the function in action.

- Touch on data types (will go into more detail later??) TODO: *Touch on data types? Determine about of detail to include for types of data in R at this stage*

# Creating our first plot

We will be using the `ggplot2` package today to make our plots. This is a very powerful package that creates professional looking plots and is one of the reasons people like using R so much. All plots made using the `ggplot2` package start by calling the `ggplot()` function. So in the tab you created for the `gdp_population.R` file, type the following:

~~~
ggplot(data=gapminder_1997)
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
In order to run code that you've typed in the editor, you have a few options. Remember that the quickest way to run the code is by pressing <kbd>Ctrl</kbd>+<kbd>Enter</kbd> on your keyboard. This will run the line of code that currently contains your cursor or any highlighted code.

When we run this code, the **Plots** tab will pop to the front in the lower right corner of the RStudio screen. Right now, we just see a big grey rectangle.

What we've done is created a ggplot object and told it we will be using the data from the `gapminder_1997` object that we've loaded into R. We've done this by calling the `ggplot()` function with `gapminder_1997` as the `data=` argument.

So we've made a plot object, now we need to start telling it what we actually want to draw in this plot. With ggplot, we start connecting our data to different plot elements by creating an "aesthetic mapping", which we do with the `aes()` function.

The elements of a plot have a bunch of properties like an x and y position, a color, a size, etc and we need to match those up to values inside our `gapminder_1997` object. When we pass our data values to the `aes()` function, we do so as if the column names of our data object are variables that exist in R. This means that what we type much match the comlumn names exactly (upper and lowercase).

The plot object will look those values up in the data object that we supplied so we can start by telling our plot object that we want to map our GDP values to the x axis of our plot. We do this by adding (`+`) information to our plot object. Add this new line to your code and run both lines by highlighting them and pressing <kbd>Ctrl</kbd>+<kbd>Enter</kbd> on your keyboard:

~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap)
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Note that we've added this new function call to a second line just to make it easier to read. To do this we make sure that the `+` is at the end of the first line otherwise R will assume your command ends when it starts the next row. The `+` sign indicates not only that we are adding information, but that there is more to come.

Observe that our **Plot** window is no longer a grey square. We now see that we've mapped the `gdpPercap` column to the x axis of our plot. Note that that column name isn't very pretty as a label, so let's use the `labs()` function to make a nicer label for the x axis


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

OK. That looks better. Notice that when we added the label value we did so by placing the values inside quotes. This is because we are not using a value from inside our data object and we are providing the name directly. When you need to include actual text values in R, they will be placed inside quotes to tell them apart from other object names.

Let's now map our `lifeExp` values to the y axis and give them a nice label.


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

Excellent. We've now told our plot object where the x and y values are coming from and what they stand for. But we haven't told our object how we want it to draw the data. There are many different plot types (bar charts, scatter plots, histograms, etc). We tell our plot object what to draw by adding a "geometry" ("geom" for short) to our object. We will talk about many different geometries today, but for our first plot, let's draw our data using points for each value in the data set. So we will add `geom_point()` to our plot object


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point()
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

Now we're really getting somewhere. It finally looks like a proper plot!  We can now see a trend in the data. It looks like countries with a larger GDP tend to have a higher life expectancy. Let's add a title to our plot to make that more clear. Again, we will use the `labs()` function, but this time we will get the `title=` argument.


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title= "Do people in wealthy countries live longer?")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

No one can deny we've made a very handsome plot. But now looking at the data, we might be curious about learning more about the points that are the extremes of the data. We know that we have two more pieces of data that we've imported that we haven't used yet. Maybe we are curious if there are any different patterns for the different continents. One thing we could do is use a different color for each of the continents. To map the color of each point to a continent, we will again use the `aes()` function


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color=continent)
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

Here we can see that in 1997 the African countries had much lower life expectancy values than many of the other groups. Notice that when we adding a mapping for color, ggplot automatically provided a legend for us. It took care of assigning different colors to each of our unique values of continent. (Note that when we mapped the x and y values, those drew the actual axis labels, so in a way the axes are like the legends for the x and y values). The colors that ggplot uses are determined by the color "scale". Each aesthetic value we can supply (x, y, color, etc) has a corresponding scale. Let's change the colors to make them a bit pritter


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent) +
  scale_color_brewer(palette = "Set1")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

The `scale_color_brewer()` function is just one of many you can use to change colors. There are bunch of "palettes" that are build in. You can view them all by running `RColorBrewer::display.brewer.all()` or check out the [Color Brewer website](https://colorbrewer2.org/) for more info about choosing plot colors.

Since we have the data for population, we might be curious what effect the population of a country might have on the life expectancy and the GDP per capita. Do you think larger countires will have a longer or shorter life expectancy? Let's find out by mapping the size of our points to the population values in our data


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent) +
  scale_color_brewer(palette = "Set1") +
  aes(size = pop)
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

There doesn't seem to be a very strong association with population size. We can see two very large countries with relatively low GDP per capita (but since the per capita value is already dividied by the total population, there is some problems with separating those two values). We got another legend here for size which is nice, but the values look a bit ugly in scientific notation. Let's divide all the values by 1,000,000 and label our legend "Population (in millions)"


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap) +
  labs(x = "GDP Per Capita") +
  aes(y = lifeExp) +
  labs(y = "Life Expectancy") +
  geom_point() +
  labs(title = "Do people in wealthy countries live longer?") +
  aes(color = continent) +
  scale_color_brewer(palette = "Set1") +
  aes(size = pop/1000000) +
  labs(size = "Population (in millions)")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
This works because you can treat the columns in the aesthetic mappings just like any other variables and can use functions to transform or change them at plot time rather than having to transform your data first.

Good work. Take a moment to appreciate what a cool plot you made with a few lines of code. In order to fully view it's beauty you can click the "Zoom" button in the **Plots** tab in order break free from the lower right corner and open the plot in it's own window.

For out first plot we added each line of oode one at a time so you could see the exact effect it had on the output. But when you start to make a bunch of plots, we can actually combine many of these steps so you don't have to type as much. For example, you can collect all the `aes()` statements and all the `labs()` together. A more condensed version of the exact same plot would look like this


~~~
ggplot(data = gapminder_1997) +
  aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) +
  geom_point() +
  scale_color_brewer(palette = "Set1") +
  labs(x = "GDP Per Capita", y = "Life Expectancy",
    title= "Do people in wealthy countries live longer?", size="Population (in millions)")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

# Plotting for data exploration

Many datasets are much more complex than the example we used for the first plot. How can we find meaningful patterns in complex data and create visualizations to convey those patterns?

## Importing datasets

In the first plot, we looked at a smaller slice of a large dataset. To gain a better understanding of the kinds of patterns we might observe in our own data, we will now used the full dataset, which is stored in a called "gapminder_data.csv".

To start, we will read in the data without using the interactive RStudio file navigation.

~~~
gapminder_data <- read_csv() # what argument (including file path) should be provided here to read in the full dataset?
~~~
{: .language-r}

Let's take a look at the full dataset.

~~~
dim(gapminder_data) # how can we find out what the data's _dim_ensions are?
head(gapminder_data) # how can we look at a snapshot of the data via the command line?
~~~
{: .language-r}
Why not use View() like we did for the smaller dataset? You can but if a data frame is too big, might take too long too long to load, so easier to look at part of it.

Notice that this table has an additional column `year` compared to the smaller dataset we started with.

Now that we have the full dataset read into our R session, let's plot the data plaing our new `year` variable on the x axis and life expeceny on the y axis. Notice that we've collapsed the plotting function options and left off some of the labels so there's not as much code to work with. Here's our code


~~~
  ggplot(data = gapminder_data) +
  aes(x=year, y=lifeExp, color=continent) +
  geom_point()
~~~
{: .language-r}
Hm, this isn't a very clear plot. What's going on?

Since the dataset is more complex, the plotting options we used for the smaller dataset aren't as useful for interpreting these data. Luckily, we can add additional attributes to our plots that will make patterns more apparant. For example, we can generate a different type of plot, a line plot, and assign attributes for columns where we might expect to see patterns.

Let's review the columns and the type of data stored in the full table to decide how we should group things together.

~~~
str(gapminder_data) # a quick way to get an overview of the data
~~~
{: .language-r}
(You can also review the structure of your data in the **Environment** tab by clicking on the blue circle with the arrow in it next to your data object name.)

So, what do we see? The column names are listed after a `$` symbol, and then we have a `:` followed by a text label. These labels correspond to the type of data stored in each column.

What kind of data do we see?
* "int"= Integer (or whole number)
* "num" = Numeric (or non-whole number)
* "Factor" = [special data object](https://www.tutorialspoint.com/r/r_factors.htm) that are used to store categorical data and have limited numbers of unique values

The unique values of a factor are tracked via the "levels" of a factor. A factor will always remember all of its levels even if the values don't actually appear in your data. The factor will also remember the order of the levels and will always print values out in the same order (by default this order is alphabetical). Here's one way to take a look at all the factors of a variable in a data object

~~~
levels(pull(gapminder_data, continent))
~~~
{: .language-r}



~~~
Error in pull(gapminder_data, continent): object 'gapminder_data' not found
~~~
{: .error}
If your columns are stored as character values, ggplot will convert them to factors for you as needed.

Our plot has a lot of points in columns which makes it hard to see trends over time. A better way to view the data showing changes over time is to use a [line plot](http://www.sthda.com/english/wiki/ggplot2-line-plot-quick-start-guide-r-software-and-data-visualization). Let's try changing the geom to a line and see what happens.


~~~
  ggplot(data = gapminder_data) +
  aes(x = year, y = lifeExp, color = continent) +
    geom_line()
~~~
{: .language-r}

Hmm. This doesn't look right. By setting the color value, we got a line for each continent, but we really wanted a line for each country. We need to tell ggplot that we want to connect the values for each "country" value instead. To do this, we need to use the `group=` aesthetic.


~~~
  ggplot(data = gapminder_data) +
  aes(x = year, y = lifeExp, group = country, color = continent) +
    geom_line()
~~~
{: .language-r}
Sometimes plots like this are called "spaghetti plots" because all the lines look like a bunch of wet noodles.

## Discrete Plots

So far we've looked at two plot types (`geom_point` and `geom_line`) which work when both the x and y values are numeric. But sometimes you may have one of your values be discrete (a factor or character).

We've previously used the discrete values of the `continent` column to color in our points and lines. But now let's try moving that varible to the `x` axis. Let's say we are curious about comparing the distribution of the life expectency values for each of the different continents for the `gapminder_1997` data. We can do so using a box plot. Here's what that code would look like


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_boxplot()
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
This type of visualiztion makes it easy to compare the range and spread of values aross groups. The "middle" 50% of the data is located inside the box and points that are far away from the central mass of the data are drawn as points.

## TODO Exercise:
Take a look a the ggplot cheat sheet. Find all the geoms listed under "Discrete X, Continuous Y". Try replacing `geom_boxplot` with one of these other values

## Layers

So far we've only been adding one geom to each plot, but each plot object can actually contain multiple layers and each layer has it's own geom. Let's start with a basic violin plot


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin()
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Violin plots are similar to box plots, but they show the range and spread of values with curves rather than boxes (wider curves = more observations) and they do not include outliers. Also note you need a minimum number of points so they can be drawn and because Ociania only has two values, it doesn't get a curve. What we fix that by adding a layer of points on top that will show us the "raw" data


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin() +
  geom_point()
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
OK, we've drawn the points but most of them stack up on top of each other. One way to make it easier to see all the data is to "jitter" the points, or move them around randomly so they don't stack up on top of each other. To do this, we use `geom_jitter` rather than `geom_point`


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin() +
  geom_jitter()
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Be aware that these movements are random so your plot will look a bit different each time you run it!

# TODO possibly make a "bonus" topic
Note that each layer can have it's own set of aestheitc mappings. So far we've been using `aes()` outside of the other functions. When we do this, we are setting the "default" ashetic mappings for the plot. It's also the same as if we had passed the values to the `ggplot()` function call as is sometimes more common: `gplot(data = gapminder_1997, aes(continent, lifeExp))` -- show how the function is inside the other function. If you want to set an aesthetic value for only one later, you an place an additioal `aes()` inside of that layer. For example, what if we wanted to change the size for just the points so they are scaled by population. We can do


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin() +
  geom_jitter(aes(size = pop))
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Both `geom_violin` and `geom_jitter` will inherit the default values of `aes(continent, lifeExp)` but only `geom_jitter` will also use `aes(size = pop)`

# TODO: Exercise
Try switching the order of `geom_violin` and `geom_jitter`. What happens? Does this make sense?

## Color vs Fill
 Let's say we want to spice up our plot a bit by adding some color. Let's say we want our violin color to a facny color like "darkolivegreen". We can do this by excplitly setting the color aestheic inside the `geom_violin` function. Note that because we are assigning a color directly and not using any values from our data to do so, we do not need to use the `aes()` mapping function. Let's try it out


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(color="darkolivegreen")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Well, that didn't get all that colorful. That's because objects like these violins have two different parts that have a color: the shape outline, and the inner part of the shape. For geoms that have an inner part, you change the fill color with `fill=` rather than `color=`, so let's try that instead


~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(fill="darkolivegreen")
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
That's some plot now isn't it. Compare this to what you see when you map the fill property to your data rather than setting a specific value.

~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(aes(fill=continent))
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

## TODO turn into exercise
So "darkolivegreen" maybe wasn't the prettiest color. R knows lots of color names. You can see the full list if you run `colors()` in the console. Since there are so many, you can randomly choose 10 if you run `sample(colors(), size=10)`. Do that a few times until you get an interesting sounding color name and swap that out for "darkolivegreen" in the violin plot example.

## TODO Bonus exercise?
What happens if you run

~~~
ggplot(data = gapminder_1997) +
  aes(x = continent, y = lifeExp) +
  geom_violin(aes(fill="springgreen"))
~~~
{: .language-r}



~~~
Error in ggplot(data = gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Why doesn't the color work? How can you fix it? Where does that color come from? (Because you are using an aesthetic mapping, the "scale" for the fill will assign colors to values)

## Univariate Plots

We jumped right into make plots with multiple columns. But what if we wanted to take a look at just one column? In that case, we only need to specify a mapping for `x` and choose an appropriate geom. Let's start with a [histogram](https://www.thoughtco.com/what-is-a-histogram-3126359) to see the range and spread of the life expectency values


~~~
ggplot(gapminder_1997) +
  aes(x = lifeExp) +
  geom_histogram()
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
You should not only see the plot in the plot window, but also a message telling you to choose a better bin value. Histograms can look very different depending on the number of bars you decide to draw. The default is 30. Let's try setting a higher value by explicitly passing a `bin=` argument to the `geom_histogram` later.


~~~
ggplot(gapminder_1997) +
  aes(x = lifeExp) +
  geom_histogram(bins=20)
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Try different values like 5 or 50 to see how the plot changes.

## TODO make exercise
Rather than a histogram, choose one of the other geometries listed under "One Variable" plots on the ggplot cheat sheet. Note that we used `lifeExp` here which has continous values. If you want to try the discrete options, try mapping `continent` to x instead.

## Facets

If you have a lot of different columns to try to plot or have distinguishable subgruops in your data, a powerful plotting technique called faceting might some in handy. When you facet your plot, you basically make a much of smaller plots and combine them together into a single image. Let's start with a simplified version of our first plot


~~~
ggplot(gapminder_1997) +
  aes(x = gdpPercap, y=lifeExp) +
  geom_point()
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}

The first time we made this plot, we colored the points differently for each of the continents. This time let's actually draw a separate box for each continent. We can do this with `facet_wrap()`


~~~
ggplot(gapminder_1997) +
  aes(x = gdpPercap, y=lifeExp) +
  geom_point() +
  facet_wrap(vars(continent))
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Note that `facet_wrap` requires this extra helper function called `vars()` in order to pass in the column names. It's a lot like the `aes()` function but it doesn't require an aesthetic name. But we can see in this output we get a separate box with a label for each continent so that only the points for that continent are in that box.

The other faceting function ggplot provides is `facet_grid()`. The main difference is that `facet_grid()` will make sure all of your smaller boxes share a common axis. In this example, we will stack all the boxes on top of each other into rows so that their x axes all line up.

~~~
ggplot(gapminder_1997) +
  aes(x = gdpPercap, y=lifeExp) +
  geom_point() +
  facet_grid(rows=vars(continent))
~~~
{: .language-r}



~~~
Error in ggplot(gapminder_1997): object 'gapminder_1997' not found
~~~
{: .error}
Unlike the `facet_wrap` output where each box got it's own x and y axis, with `facet_grid()`, there is only one x axis along the bottom.

## Saving plots

We've made a bunch of plots today, but we never talked about how to share them with your friends who aren't running R! It's wise to keep all the code you used to draw the plot, but sometimes you need to make a PNG or PDF version of the plot so you can share it with your PI or post it to your Instagram story.

One what's easy if you are working in RStudio interactively is to use "Export" menu on the **Plots** tab. Clicking that button gives you three options "Save as Image", "Save as PDF", and "Copy To Clipboard". These options will bring up a window that will let you resize and name the plot however you like.

A better option if you will be running your code as a script from the command line or just need your code to be more reproduicble is to use the `ggsave()` function. When you call this function, it will write the last plot printed to a file in your local directory. It will determine the file type based on the name you provide. So if you call `ggsave("plot.png")` you'll get a PNG file or if you call `ggsave("plot.pdf")` you'll get a PDF file. By default the size will match the size of the **Plots** tab. To change that you can also supply `width=` and `height=` arguments. By default these values are interpreted as inches. So if you want a wide 4x6 image you could do something like


~~~
ggsave("awsome_plot.jpg", width=6, height=4)
~~~
{: .language-r}

## Glossary of terms

- Aesthetic: a visual property of the objects (geoms) drawn in your plot (like x position, y position, color, size, etc)
- Aesthetic mapping (aes): This is how we connect a visual property of the plot to a column of our data
- Geometry (geom): this describes the things that are actually drawn on the plot (like points or lines)
- Facets: Dividing your data into non-overlapping groups and making a small plot for each subgroup
- Layer: Each ggplot is made up of one or more layers. Each layer contains one geometry and may also contain custom aesthetic mappings and private data
- Factor: a way of storing data to let R know the values are discrete so they get special treatment


# Extra ideas

PLOT MAYBE (map)
mapdata <- map_data("world") %>%
  mutate(region = recode(region,
                         USA="United States",
                         UK="United Kingdom"))

#install.packages("mapproj")
gapminder %>% filter(year==2007) %>%
  ggplot() +
  geom_map(aes(map_id=country, fill=lifeExp), map=mapdata) +
  expand_limits(x = mapdata$long, y = mapdata$lat) +
  coord_map(projection = "mollweide", xlim = c(-180, 180)) +
  ggthemes::theme_map()

PLOT MAYBE (animation)
gganimation -- recreate Hans Rosling's moving plot

Plot Themes - classic, bw, grey
